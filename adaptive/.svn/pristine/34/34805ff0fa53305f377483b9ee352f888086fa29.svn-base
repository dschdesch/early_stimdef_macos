function P2 = makestimTHR(P)

P2 = []; % a premature return will result in []
if isempty(P), return; end
figh = P.handle.GUIfig;
EXP = P.Experiment;

% P.Freq is and P.SPL are used for calculating waveforms.
% P.Fcar and P.SPL are used for representation.

P.Freq_masker = EvalFrequencyStepper(figh, 'masker', P);
if isempty(P.Freq_masker), return; end

P.dB_masker=EvaldB_maskerstepper(figh, '', P);
if isempty(P.dB_masker), return; end


% SPL
P.SPL=evalSPLstepper(figh, '', P);
if isempty(P.SPL), return; end

% % Check validity of BeginSPL
if mod(P.BeginSPL - P.StartSPL, P.StepSPL) ~= 0, return; end

% % Levels and active channels (must be called *after* adding the baseline waveforms)
% [mxSPL P.Attenuation] = maxSPL(P.Waveform, P.Experiment);
% okay=evalSPLpanel(figh,P, mxSPL, P.Fcar);
% if ~okay, return; end

% % amplitudes -> replace by evalStepper?
% NSPL = 1+round((P.EndSPL-P.StartSPL)/P.StepSPL);
% SPL = linspace(P.StartSPL, P.EndSPL, NSPL);

% P.BurstDur = 100;
%P.ISI = P.BurstDur;
P.FreqTolMode = 'exact';
[P.ModFreq, P.ModDepth, P.ModStartPhase, P.ModTheta, ...
    P.OnsetDelay, P.RiseDur, P.FallDur, P.WavePhase, ...
    P.FineITD, P.GateITD, P.ModITD] = deal(0);

% mix Freq & SPL sweeps; # conditions = # Freqs times # SPLs. By
% convention, SPL is updated faster.
[dum1, dum2, P.Ncond_XY] = MixSweeps(P.dB_masker, P.Freq_masker);
NFreq_masker = P.Ncond_XY(2);
NSPL_masker = P.Ncond_XY(1);

NFreq = 10

% amplitude of the probe
%get attenuation from it
Fcar = P.Freq; %probe
SPL = P.SPL;%probe
Fsam = sampleRate(Fcar, EXP);
if strcmpi(P.DAC(1),'L') || strcmpi(P.DAC(1),'B') ,
    DLL = calibrate(EXP, Fsam, 'L', P.Freq);
    Amp = dB2a(SPL)*sqrt(2)*dB2A(DLL);
    % Get attenuation settings
    [dum, Atten] = local_maxSPL(max(SPL),max(Amp),EXP);
    P.Attenuations(1,1) = Atten.AnaAtten;
    P.LinAmp(:,1) = Amp.*Atten.NumScale;
end
if strcmpi(P.DAC(1),'R') || strcmpi(P.DAC(1),'B')
    DLL = calibrate(EXP, Fsam, 'R', P.Freq);
    Amp = dB2a(SPL)*sqrt(2)*dB2A(DLL);
    % Get attenuation settings
    [dum, Atten] = local_maxSPL(max(SPL),max(Amp),EXP);
    P.Attenuations(1,end) = Atten.AnaAtten;
    P.LinAmp(:,end) = Amp.*Atten.NumScale;
end
[P.Attenuations, P.LinAmp] = channelSelect(P.DAC(1),P.Attenuations, P.LinAmp);       
        
% Calculate all required # Freqs times # SPLs numerical amplitudes
P.LinAmp_masker = deal(nan+zeros(prod([NFreq_masker NSPL_masker]),size(P.SPL,2)));
[P.LinAmp] = channelSelect(P.DAC(1), P.LinAmp);

% Get right numerical amplitudes and attenuation settings per Freq
icount=1
for ifreq_masker=1:NFreq_masker;
    for iSPL_masker=1:NSPL_masker;
        
        freq_masker = P.Freq_masker(ifreq_masker);
        SPL_masker = P.dB_masker(iSPL_masker);
        icount=icount+1;
        
        % Calibrate for Freq(ifreq)
        if strcmpi(P.DAC(1),'L') || strcmpi(P.DAC(1),'B') ,
            DLL_masker = calibrate(EXP, Fsam, 'L', freq_masker);
            Amp_masker = dB2a(SPL_masker)*sqrt(2)*dB2A(DLL_masker);
            P.LinAmp_masker(icount,1) = Amp_masker.*Atten.NumScale;
        end
  
        if strcmpi(P.DAC(1),'R') || strcmpi(P.DAC(1),'B')
            DLL_masker = calibrate(EXP, Fsam, 'R', freq_masker);
            Amp_masker = dB2a(SPL_masker)*sqrt(2)*dB2A(DLL_masker);
            P.LinAmp_masker(icount,end) = Amp_masker.*Atten.NumScale;
        end
        
    end
end

% Representation
P.SPLs = P.SPL;
SPL=P.StartSPL;%evalSPLstepper(figh, '', P); DUMMY TO AVOID EXCESSIVE TIME USE
if isempty(SPL), return; end
[P.SPL, P.Fcar, P.Ncond_XY] = MixSweeps(P.dB_masker, P.Freq_masker);

P = toneStim(P);

P.Nrep = 1;
P.RSeed = 0;
% P.Slowest = 'Fcar';
% P.Nextslow = 'SPL';
% P.Fastest = 'Rep';
P.Xorder = P.Order;
% P.Yorder = 'Forward';
P.Xname = 'Fcar';
% P.Yname = 'SPL';
P.Grouping = 'by condition';
P.Baseline = 0;
P.ITD = 0;
P.ITDtype = 'ongoing';
P.StimType = 'THR';
% P.Presentation.X.PlotVal = P.Fcar;
% P.Presentation.X.ParUnit = P.StepFreqUnit;
% P.Presentation.Nrep = 1;
% P.Presentation.Ncond = size(P.Fcar,1);
% P.Presentation.PresDur = P.BurstDur;
%
P = sortConditions(P, 'dB_masker', 'Freq_masker', ...
    'dB', P.StepFreq_maskerUnit);
% 'TESTING MAKEDTIMFS'
% P.Duration
% P.Duration = []; %
% P.Fcar = [];

% everything okay: return P
P2=P;

function [mxSPL, Atten] = local_maxSPL(SPLs,Amp,EXP)
DACmax = EXP.AudioMaxAbsDA;
mxSPL = nan+zeros(size(SPLs)); % correct size, all nans
for ii=1:numel(SPLs),
    % Find out how much waveforms can be boosted w/o exceeding the
    % max magnitude DACmax tolerated by the DAC
    mxSPL(ii) = SPLs(ii) + a2db(DACmax/Amp(ii)) - 0.1;
end

AnaAtten = 0;
% Numerical amplification toward the ceiling is often possible as
% long as it can be compensated by analog attenuation. Be aware that
% the analog attenuator cannot be set during stimulus delivery. So the
% extra gain must be applied to all stimuli in a given DAC channel.
Gain = min(mxSPL - SPLs); % max along first dim, i.e. per channel=column
AnaAtten = Gain; % compensate the gain

% If there is enough clearance, use the preferred minimum numerical
% attenuation at the cost of analog attenution. This may help reduce
% the amount of distortion occurring at high DAC output Voltages.
ExtraNumAtten = min(AnaAtten, EXP.PreferredNumAtten);
AnaAtten = AnaAtten - ExtraNumAtten;
Gain = Gain - SameSize(ExtraNumAtten, Gain);

% If the analog attenuation exceeds the range of the attenuator, replace
% part of it by numerical attenuation
switch EXP.Attenuators,
    case 'PA5', MaxAtten = 90; % dB max attenuation (higher range of PA5s is unreliable)
    case '-', MaxAtten = 0; % dB
    otherwise,
        error(['Unknown attenuators ''' EXP.Attenuators ''' specified.']);
end
AnaExcess = max(0,AnaAtten-MaxAtten);
AnaAtten = AnaAtten-AnaExcess;
Gain = Gain - AnaExcess;

% the analog attenuators are accurate to 0.1 dB. Take care of rounding
% errors.
RoundingCorrection = AnaAtten-0.1*floor(10*AnaAtten);
AnaAtten = AnaAtten-RoundingCorrection;
Gain = Gain - SameSize(RoundingCorrection, Gain);

Gain = samesize(Gain,SPLs);
NumScale = db2a(Gain);
NumGain_dB = Gain; % for the record
Atten = CollectInStruct(AnaAtten, NumScale, NumGain_dB);









